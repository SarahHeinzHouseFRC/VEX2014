#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  solenoid1,      sensorDigitalOut)
#pragma config(Sensor, dgtl2,  solenoid2,      sensorDigitalOut)
#pragma config(Sensor, dgtl5,  frontSonar,     sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  rearSonar,      sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  override,       sensorTouch)
#pragma config(Sensor, I2C_1,  liftRight,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  liftLeft,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  intakeLeft,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  driveLeft,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  driveRight,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightArm1,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           intakeRight,   tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           intakeLeft,    tmotorVex393, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port4,           driveLeftFront, tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port5,           driveLeftBack, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port6,           driveRightFront, tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port7,           driveRightBack, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port8,           LiftRight,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port9,           LiftLeft,      tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port10,          leftArm1,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int nTimeXX = 0;
void allMotorsOff();
void allTasksStop();
void clearScreen();
bool overrideAll();

//#include "settings.h"
//#include "globalFunctions.c"
//#include "pistonControl.c"
//#include "PID Turn.c"
//#include "autonFunctions.c"
//#include "autonSelection.c"
//#include "teliopFunctions.c"
//#include "autons.c"
//#include "watchDog.c"
int position;

task main()
{
	while(true)
	{

		if (-nMotorEncoder[LiftLeft] > position && nMotorEncoder[LiftRight] > position)
		{
			while(-nMotorEncoder[LiftLeft] > position && nMotorEncoder[LiftRight] > position)
			{
				motor[LiftLeft] = 127;
				motor[LiftRight] = 127;
			}

			while(-nMotorEncoder[LiftLeft] > position)
			{
				motor[LiftLeft] = 127;
				motor[LiftRight] = 0;
			}
			while(nMotorEncoder[LiftRight] > position)
			{
				motor[LiftRight] = 127;
				motor[LiftLeft] = 0;
			}
			motor[LiftLeft] = 0;
			motor[LiftRight] = 0;
		}

		else if (-nMotorEncoder[LiftLeft] < position && nMotorEncoder[LiftRight] < position)
		{
			while(-nMotorEncoder[LiftLeft] < position && nMotorEncoder[LiftRight] < position)
			{
				motor[LiftLeft] = -127;
				motor[LiftRight] = -127;
			}

			while(-nMotorEncoder[LiftLeft] < position)
			{
				motor[LiftLeft] = -127;
				motor[LiftRight] = 0;
			}
			while(nMotorEncoder[LiftRight] < position)
			{
				motor[LiftRight] = -127;
				motor[LiftLeft] = 0;
			}
			motor[LiftLeft] = 0;
			motor[LiftRight] = 0;
		}
		motor[LiftLeft] = 0;
		motor[LiftRight] = 0;
	}


}

void allMotorsOff()
{
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	motor[port10] = 0;
}

void allTasksStop()
{
	StopTask(1);
	StopTask(2);
	StopTask(3);
	StopTask(4);
	StopTask(5);
	StopTask(6);
	StopTask(7);
	StopTask(8);
	StopTask(9);
	StopTask(10);
	StopTask(11);
	StopTask(12);
	StopTask(13);
	StopTask(14);
	StopTask(15);
	StopTask(16);
	StopTask(17);
	StopTask(18);
	StopTask(19);
}

static void displayTime()
{
	displayLCDPos(1, 0);
	displayNextLCDNumber(nTimeXX / 600, 2);
	displayNextLCDChar(':');
	displayNextLCDNumber((nTimeXX / 10) % 60, -2);
	displayNextLCDChar('.');
	displayNextLCDNumber(nTimeXX % 10, 1);
}

void clearScreen()
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDPos(0, 0);
}

bool overrideAll()
{
	if((vexRT[Btn6UXmtr2] == 1 && vexRT[Btn6DXmtr2] == 1) || (vexRT[Btn6U] == 1 && vexRT[Btn6D] == 1) || SensorValue[override])
		return(true);
	else
		return(false);
}
